# Artificial Intelligence - DD2380

## Assignment 1: HMMs (Hidden Markov Models)

A Hidden Markov Model (HMM) is a powerful statistical model used in robotics, computational biology and many other disciplines. HMMs build on the idea that observations are generated by unknown or hidden states.

<details>
  <summary>QUESTIONS</summary>
  
### HMM0 - Next Observation Distribution
In this task you should show that you know how to predict how the system will evolve over time and estimate the probability for different emissions / events in the system i.e. what can be observed from the HMM. You will be given the state probability distribution (i.e. the probability that the system is in each of the N states), the transition matrix (i.e. the matrix that gives the probability to transition from one state to another) and the emission matrix (i.e. the matrix that gives the probability for the different emissions / events / observations given a certain state).

More specifically, given the current state probability distribution what is the probabity for the different emissions after the next transition (i.e. after the system has made a single transition)?

### HMM1 - Probability of Emission Sequence
In this task you should show that you know how to calculate the probability to observe a certain emission sequence given a HMM model. You will be given the HMM model and a sequence of observations (aka emissions, events, etc) and your task is to calculate the probability for this sequence.

### HMM2 - Estimate Sequence of States
In this task you should show that you know how to calculate the most likely sequence of (hidden) states that the system moves through given an emission sequence and an HMM model.

### HMM3 - Estimate Model
In this task you should show that you know how to estimate the model parameters for an HMM. You will be given a starting guess of a HMM (transition matrix, emission matrix and initial state probability distribution) and a sequence of emissions and you should train the HMM to maximize the probability of observing the given sequence of emissions.

### Duck Hunt: 
This version of Duck Hunt is a generalized version of the original game: there is a sky with birds flying. The birds fly around the sky until they are shot down. The player has to observe the flight patterns of the birds and predict their next move in order to shoot them down. If the prediction is correct, the player will hit the bird and gain one point. If the prediction is wrong the player will miss the bird and lose one point. The game is over when all birds are shot down or when the time runs out.

We have also added different species of birds which behave differently in the air. Most birds give one point when shot, but one of the species is very rare and will hurt your score seriously if you shoot it. The species are identified after each round. In order to prioritize your targets you will need to identify them during flight.

The players may also bet on the species of each bird after each round finishes. The players will get one point for each correct guess and lose one point for each incorrect guess. Guessing is optional, you will choose to guess or not for each bird. The score will be unaffected if no guessing is made. You will get to know the correct species for each bird you make a guess on regardless of whether your guess was correct or not.

#### AI Perspective
This version of the game can be broken down into three main, dependent, topics:

1) Predicting the flight trajectory of the birds so that they can be shot down.

2) Make decisions to shoot or not based on the confidence of prediction of bird species and flight trajectory.

3) Identifying the bird species to avoid forbidden targets and maximize score.

Tip: Focus on predicting the movement of a single bird using a HMM. This is the building block to solve the entire homework.
  
#### Gameplay specifics
The sky is considered flat and the birds can move in the eight basic directions (up, down, left, right, up-left, up-right, down-left, down-right). Some birds can also stop mid-air and hover. They do not have absolute positions as far as you are concerned. Only the direction of the movement is important. Every bird in the sky makes a move for every discrete time step that the game runs. No moves are reported for birds that have been shot.

The birds have different flight patterns. A particular species displays only a few flight patterns and different species may have different variations of them. The patterns may look like this:

- Migrating: The bird will fly mostly in one direction. Different species may migrate in different directions but all birds of the same species will migrate in the same direction in a given environment.

- Circling: The bird gains height by flying up-left or up-right.

- Hunting: The bird dives or flies horizontally back and forth to hunt insects.

- Drilling: To impress on the opposite sex, the bird makes cool tricks in the air. Different species have different drills.

- Zig-zag: This is an erratic flight pattern. The bird flies in different directions to avoid predators.

The goal of the game is to shoot all birds except black storks. The game is divided into several environments with several rounds of shooting. The different environments contains different distributions of birds and the birds may also behave differently in different environment.

There will be up to 10 rounds in each environment. Each round contains 1-20 birds and goes on for 100 time steps. The round will end when all birds are shot or when time runs out. If you hit a black stork, you can not play any more rounds in that environment and all your points from that environment will be lost. You will still keep your score from the other environments and may continue to the next. The program will be restarted between each environment, so you cannot transfer any information between them.
  
#### Run code
To run on computer labs do the following:

1) COMPILE: javac *.java

2) CREATE PIPE: mkfifo /tmp/player2server /tmp/server2player

3) RUN: java Main server < /tmp/player2server | java Main verbose > /tmp/player2server

</details>

## Assignment 2: Games

Game theory studies systems where two or more agents try to maximize their own gain by operating on a shared stated.  In this assignment, we are interested in a special class of such problems, namely one where two players are in direct conflict (which are commonly called zero-sum games).

<details>
  <summary>QUESTIONS</summary>
  
### 2D Tic-tac-toe
In this problem, you will implement a program that plays the game of Tic-Tac-Toe. Your goal is to implement a strategy that allows your program to win (or not lose) as often as possible. You will be provided a skeleton which generates a list of valid moves for you to choose from (see section ).

There is an square board H, consisting of 16 cells. Two players, X and Y, take turns marking blank cells in H. The first player to mark 4 cells along a row wins. Here by a row we mean any 4 cells, whose centres lie along a straight line in H. So, any horizontal, vertical and diagonal row is winning.

In this assignment, our goal is to find the best possible move for player X given a particular state of the game.

### 3D Tic-tac-toe
In this problem, you will implement a program that plays the game of Tic-Tac-Toe. Your goal is to implement a strategy that allows your program to win (or not lose) as often as possible. You will be provided a skeleton which generates a list of valid moves for you to choose from (see section ).

In this assignment we consider a special case of 3-dimensional generalization of Tic-Tac-Toe game. The rules are simple. There is a 3-dimensional hypercube H, consisting of 43 cells. Two players, X and Y, take turns marking blank cells in H. The first player to mark 4 cells along a row wins. Here by a row we mean any 4 cells, whose centres lie along a straight line in H. Winning rows lie along the 48 orthogonal rows (those which are parallel to one of the edges of the cube), the 24 diagonal rows, or the 4 main diagonals of the cube, making 76 winning rows in total. Player X always starts the game.

In this assignment, our goal is to find the best possible move for player X given a particular state of the game.

### Checkers
In this problem, you will implement a program that plays the game of checkers (also known as English draughts). Your goal is to implement a strategy that allows your program to win (or not lose) as often as possible. You will be provided a skeleton which generates a list of valid moves for you to choose from (see section 2).

The game of checkers is played by two players, on opposite sides of a squared board. Each player has twelve pieces, which can move diagonally. The goal of the game is to leave your opponent without any movement possibility. This is achieved usually by capturing all of the opponents pieces by jumping over them.

#### Valid moves
The players move in turns, alternately. Red player first. In their own turn, a player can move one of their own pieces. All movements are performed diagonally, which means that since all pieces start in green cells, they will always stay in green cells.

Normal pieces can only move forwards (downwards for red pieces, upwards for white pieces). Kings can move in any diagonal direction.

You have one second to make a move.

There are two types of moves:

1) Normal move
Pieces can be moved diagonally forward, to an adjacent empty square in the next row. Kings can also move backward, to an empty square in the previous row.
2) Jumping
If the adjacent square in the next row is occupied by an opponent’s piece, and the square immediately and directly opposite that square is empty, the piece can “jump” over the opponent’s piece. Normal pieces can only jump forward, while kings can also jump backward. The piece that is jumped over is captured and removed from the board. It is possible to perform multiple jumps in the same turn, if when the piece lands, there is another immediate piece that can be jumped, even if the jump is in a different direction.
Jumping is mandatory: whenever it is possible to perform a jump, it is not possible to perform a normal move. When more than one jump or multiple jump is available, the player can choose which piece to jump with, and which sequence of jumps to perform. It is not necessary to perform the multiple jump that captures the most pieces. However, it is mandatory to perform all the jumps in the chosen sequence: the moved piece cannot end in a position where another jump would be possible.

If a piece moves into the last row, that piece is “crowned” and becomes a king. The piece that becomes a king after a jump, cannot immediately jump backward over another piece.

#### End of game
A player wins by capturing all the opponent’s pieces, or by leaving the opponent with no valid moves. If no pieces are captured for 50 turns (25 of each player), the game is considered a draw.

</details>
